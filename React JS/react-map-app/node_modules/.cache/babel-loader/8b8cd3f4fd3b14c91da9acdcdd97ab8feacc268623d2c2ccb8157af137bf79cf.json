{"ast":null,"code":"(function (GeoJSON) {\n  GeoJSON.version = '0.5.0';\n\n  // Allow user to specify default parameters\n  GeoJSON.defaults = {\n    doThrows: {\n      invalidGeometry: false\n    }\n  };\n  function InvalidGeometryError() {\n    var args = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];\n    var item = args.shift();\n    var params = args.shift();\n    Error.apply(this, args);\n    this.message = this.message || \"Invalid Geometry: \" + 'item: ' + JSON.stringify(item) + ', params: ' + JSON.stringify(params);\n  }\n  InvalidGeometryError.prototype = Error;\n  GeoJSON.errors = {\n    InvalidGeometryError: InvalidGeometryError\n  };\n\n  //exposing so this can be overriden maybe by geojson-validation or the like\n  GeoJSON.isGeometryValid = function (geometry) {\n    if (!geometry || !Object.keys(geometry).length) return false;\n    return !!geometry.type && !!geometry.coordinates && Array.isArray(geometry.coordinates) && !!geometry.coordinates.length;\n  };\n\n  // The one and only public function.\n  // Converts an array of objects into a GeoJSON feature collection\n  GeoJSON.parse = function (objects, params, callback) {\n    var geojson,\n      settings = applyDefaults(params, this.defaults),\n      propFunc;\n    geomAttrs.length = 0; // Reset the list of geometry fields\n    setGeom(settings);\n    propFunc = getPropFunction(settings);\n    if (Array.isArray(objects)) {\n      geojson = {\n        \"type\": \"FeatureCollection\",\n        \"features\": []\n      };\n      objects.forEach(function (item) {\n        geojson.features.push(getFeature({\n          item: item,\n          params: settings,\n          propFunc: propFunc\n        }));\n      });\n      addOptionals(geojson, settings);\n    } else {\n      geojson = getFeature({\n        item: objects,\n        params: settings,\n        propFunc: propFunc\n      });\n      addOptionals(geojson, settings);\n    }\n    if (callback && typeof callback === 'function') {\n      callback(geojson);\n    } else {\n      return geojson;\n    }\n  };\n\n  // Helper functions\n  var geoms = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon', 'GeoJSON'],\n    geomAttrs = [];\n\n  // Adds default settings to user-specified params\n  // Does not overwrite any settings--only adds defaults\n  // the the user did not specify\n  function applyDefaults(params, defaults) {\n    var settings = params || {};\n    for (var setting in defaults) {\n      if (defaults.hasOwnProperty(setting) && !settings[setting]) {\n        settings[setting] = defaults[setting];\n      }\n    }\n    return settings;\n  }\n\n  // Adds the optional GeoJSON properties crs and bbox\n  // if they have been specified\n  function addOptionals(geojson, settings) {\n    if (settings.crs && checkCRS(settings.crs)) {\n      if (settings.isPostgres) geojson.geometry.crs = settings.crs;else geojson.crs = settings.crs;\n    }\n    if (settings.bbox) {\n      geojson.bbox = settings.bbox;\n    }\n    if (settings.extraGlobal) {\n      geojson.properties = {};\n      for (var key in settings.extraGlobal) {\n        geojson.properties[key] = settings.extraGlobal[key];\n      }\n    }\n  }\n\n  // Verify that the structure of CRS object is valid\n  function checkCRS(crs) {\n    if (crs.type === 'name') {\n      if (crs.properties && crs.properties.name) {\n        return true;\n      } else {\n        throw new Error('Invalid CRS. Properties must contain \"name\" key');\n      }\n    } else if (crs.type === 'link') {\n      if (crs.properties && crs.properties.href && crs.properties.type) {\n        return true;\n      } else {\n        throw new Error('Invalid CRS. Properties must contain \"href\" and \"type\" key');\n      }\n    } else {\n      throw new Error('Invald CRS. Type attribute must be \"name\" or \"link\"');\n    }\n  }\n\n  // Moves the user-specified geometry parameters\n  // under the `geom` key in param for easier access\n  function setGeom(params) {\n    params.geom = {};\n    for (var param in params) {\n      if (params.hasOwnProperty(param) && geoms.indexOf(param) !== -1) {\n        params.geom[param] = params[param];\n        delete params[param];\n      }\n    }\n    setGeomAttrList(params.geom);\n  }\n\n  // Adds fields which contain geometry data\n  // to geomAttrs. This list is used when adding\n  // properties to the features so that no geometry\n  // fields are added the properties key\n  function setGeomAttrList(params) {\n    for (var param in params) {\n      if (params.hasOwnProperty(param)) {\n        if (typeof params[param] === 'string') {\n          geomAttrs.push(params[param]);\n        } else if (typeof params[param] === 'object') {\n          // Array of coordinates for Point\n          geomAttrs.push(params[param][0]);\n          geomAttrs.push(params[param][1]);\n        }\n      }\n    }\n    if (geomAttrs.length === 0) {\n      throw new Error('No geometry attributes specified');\n    }\n  }\n\n  // Creates a feature object to be added\n  // to the GeoJSON features array\n  function getFeature(args) {\n    var item = args.item,\n      params = args.params,\n      propFunc = args.propFunc;\n    var feature = {\n      \"type\": \"Feature\"\n    };\n    feature.geometry = buildGeom(item, params);\n    feature.properties = propFunc.call(item);\n    return feature;\n  }\n  function isNested(val) {\n    return /^.+\\..+$/.test(val);\n  }\n\n  // Assembles the `geometry` property\n  // for the feature output\n  function buildGeom(item, params) {\n    var geom = {},\n      attr;\n    for (var gtype in params.geom) {\n      var val = params.geom[gtype];\n\n      // Geometry parameter specified as: {Point: 'coords'}\n      if (typeof val === 'string' && item.hasOwnProperty(val)) {\n        if (gtype === 'GeoJSON') {\n          geom = item[val];\n        } else {\n          geom.type = gtype;\n          geom.coordinates = item[val];\n        }\n      }\n\n      /* Handle things like:\n      Polygon: {\n        northeast: ['lat', 'lng'],\n        southwest: ['lat', 'lng']\n      }\n      */else if (typeof val === 'object' && !Array.isArray(val)) {\n        /*jshint loopfunc: true */\n        var points = Object.keys(val).map(function (key) {\n          var order = val[key];\n          var newItem = item[key];\n          return buildGeom(newItem, {\n            geom: {\n              Point: order\n            }\n          });\n        });\n        geom.type = gtype;\n        /*jshint loopfunc: true */\n        geom.coordinates = [].concat(points.map(function (p) {\n          return p.coordinates;\n        }));\n      }\n\n      // Geometry parameter specified as: {Point: ['lat', 'lng']}\n      else if (Array.isArray(val) && item.hasOwnProperty(val[0]) && item.hasOwnProperty(val[1])) {\n        geom.type = gtype;\n        geom.coordinates = [Number(item[val[1]]), Number(item[val[0]])];\n      }\n\n      // Geometry parameter specified as: {Point: ['container.lat', 'container.lng']}\n      else if (Array.isArray(val) && isNested(val[0]) && isNested(val[1])) {\n        var coordinates = [];\n        for (var i = 0; i < val.length; i++) {\n          // i.e. 0 and 1\n          var paths = val[i].split('.');\n          var itemClone = item;\n          for (var j = 0; j < paths.length; j++) {\n            if (!itemClone.hasOwnProperty(paths[j])) {\n              return false;\n            }\n            itemClone = itemClone[paths[j]]; // Iterate deeper into the object\n          }\n\n          coordinates[i] = itemClone;\n        }\n        geom.type = gtype;\n        geom.coordinates = [Number(coordinates[1]), Number(coordinates[0])];\n      }\n    }\n    if (params.doThrows && params.doThrows.invalidGeometry && !GeoJSON.isGeometryValid(geom)) {\n      throw new InvalidGeometryError(item, params);\n    }\n    return geom;\n  }\n\n  // Returns the function to be used to\n  // build the properties object for each feature\n  function getPropFunction(params) {\n    var func;\n    if (!params.exclude && !params.include) {\n      func = function (properties) {\n        for (var attr in this) {\n          if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1) {\n            properties[attr] = this[attr];\n          }\n        }\n      };\n    } else if (params.include) {\n      func = function (properties) {\n        params.include.forEach(function (attr) {\n          properties[attr] = this[attr];\n        }, this);\n      };\n    } else if (params.exclude) {\n      func = function (properties) {\n        for (var attr in this) {\n          if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1 && params.exclude.indexOf(attr) === -1) {\n            properties[attr] = this[attr];\n          }\n        }\n      };\n    }\n    return function () {\n      var properties = {};\n      func.call(this, properties);\n      if (params.extra) {\n        addExtra(properties, params.extra);\n      }\n      return properties;\n    };\n  }\n\n  // Adds data contained in the `extra`\n  // parameter if it has been specified\n  function addExtra(properties, extra) {\n    for (var key in extra) {\n      if (extra.hasOwnProperty(key)) {\n        properties[key] = extra[key];\n      }\n    }\n    return properties;\n  }\n})(typeof module == 'object' ? module.exports : window.GeoJSON = {});","map":{"version":3,"names":["GeoJSON","version","defaults","doThrows","invalidGeometry","InvalidGeometryError","args","arguments","length","slice","call","item","shift","params","Error","apply","message","JSON","stringify","prototype","errors","isGeometryValid","geometry","Object","keys","type","coordinates","Array","isArray","parse","objects","callback","geojson","settings","applyDefaults","propFunc","geomAttrs","setGeom","getPropFunction","forEach","features","push","getFeature","addOptionals","geoms","setting","hasOwnProperty","crs","checkCRS","isPostgres","bbox","extraGlobal","properties","key","name","href","geom","param","indexOf","setGeomAttrList","feature","buildGeom","isNested","val","test","attr","gtype","points","map","order","newItem","Point","concat","p","Number","i","paths","split","itemClone","j","func","exclude","include","extra","addExtra","module","exports","window"],"sources":["/home/divum/Desktop/Workspace/GitHub1122/React JS/react-map-app/node_modules/geojson/geojson.js"],"sourcesContent":["(function(GeoJSON) {\n  GeoJSON.version = '0.5.0';\n\n  // Allow user to specify default parameters\n  GeoJSON.defaults = {\n    doThrows: {\n      invalidGeometry: false\n    }\n  };\n\n  function InvalidGeometryError() {\n    var args = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];\n    var item = args.shift();\n    var params = args.shift();\n\n    Error.apply(this, args);\n    this.message = this.message || \"Invalid Geometry: \" + 'item: ' + JSON.stringify(item) + ', params: ' + JSON.stringify(params);\n  }\n\n  InvalidGeometryError.prototype = Error;\n\n\n  GeoJSON.errors = {\n    InvalidGeometryError: InvalidGeometryError\n  };\n\n  //exposing so this can be overriden maybe by geojson-validation or the like\n  GeoJSON.isGeometryValid = function(geometry){\n    if(!geometry || !Object.keys(geometry).length)\n      return false;\n\n    return !!geometry.type && !!geometry.coordinates && Array.isArray(geometry.coordinates) && !!geometry.coordinates.length;\n  };\n\n  // The one and only public function.\n  // Converts an array of objects into a GeoJSON feature collection\n  GeoJSON.parse = function(objects, params, callback) {\n    var geojson,\n        settings = applyDefaults(params, this.defaults),\n        propFunc;\n\n    geomAttrs.length = 0; // Reset the list of geometry fields\n    setGeom(settings);\n    propFunc = getPropFunction(settings);\n\n    if (Array.isArray(objects)) {\n      geojson = {\"type\": \"FeatureCollection\", \"features\": []};\n      objects.forEach(function(item){\n        geojson.features.push(getFeature({item:item, params: settings, propFunc:propFunc}));\n      });\n      addOptionals(geojson, settings);\n    } else {\n      geojson = getFeature({item:objects, params: settings, propFunc:propFunc});\n      addOptionals(geojson, settings);\n    }\n\n    if (callback && typeof callback === 'function') {\n      callback(geojson);\n    } else {\n      return geojson;\n    }\n  };\n\n  // Helper functions\n  var geoms = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon', 'GeoJSON'],\n      geomAttrs = [];\n\n  // Adds default settings to user-specified params\n  // Does not overwrite any settings--only adds defaults\n  // the the user did not specify\n  function applyDefaults(params, defaults) {\n    var settings = params || {};\n\n    for(var setting in defaults) {\n      if(defaults.hasOwnProperty(setting) && !settings[setting]) {\n        settings[setting] = defaults[setting];\n      }\n    }\n\n    return settings;\n  }\n\n  // Adds the optional GeoJSON properties crs and bbox\n  // if they have been specified\n  function addOptionals(geojson, settings){\n    if(settings.crs && checkCRS(settings.crs)) {\n      if(settings.isPostgres)\n        geojson.geometry.crs = settings.crs;\n      else\n        geojson.crs = settings.crs;\n    }\n    if (settings.bbox) {\n      geojson.bbox = settings.bbox;\n    }\n    if (settings.extraGlobal) {\n      geojson.properties = {};\n      for (var key in settings.extraGlobal) {\n        geojson.properties[key] = settings.extraGlobal[key];\n      }\n    }\n  }\n\n  // Verify that the structure of CRS object is valid\n  function checkCRS(crs) {\n    if (crs.type === 'name') {\n        if (crs.properties && crs.properties.name) {\n            return true;\n        } else {\n            throw new Error('Invalid CRS. Properties must contain \"name\" key');\n        }\n    } else if (crs.type === 'link') {\n        if (crs.properties && crs.properties.href && crs.properties.type) {\n            return true;\n        } else {\n            throw new Error('Invalid CRS. Properties must contain \"href\" and \"type\" key');\n        }\n    } else {\n        throw new Error('Invald CRS. Type attribute must be \"name\" or \"link\"');\n    }\n  }\n\n  // Moves the user-specified geometry parameters\n  // under the `geom` key in param for easier access\n  function setGeom(params) {\n    params.geom = {};\n\n    for(var param in params) {\n      if(params.hasOwnProperty(param) && geoms.indexOf(param) !== -1){\n        params.geom[param] = params[param];\n        delete params[param];\n      }\n    }\n\n    setGeomAttrList(params.geom);\n  }\n\n  // Adds fields which contain geometry data\n  // to geomAttrs. This list is used when adding\n  // properties to the features so that no geometry\n  // fields are added the properties key\n  function setGeomAttrList(params) {\n    for(var param in params) {\n      if(params.hasOwnProperty(param)) {\n        if(typeof params[param] === 'string') {\n          geomAttrs.push(params[param]);\n        } else if (typeof params[param] === 'object') { // Array of coordinates for Point\n          geomAttrs.push(params[param][0]);\n          geomAttrs.push(params[param][1]);\n        }\n      }\n    }\n\n    if(geomAttrs.length === 0) { throw new Error('No geometry attributes specified'); }\n  }\n\n  // Creates a feature object to be added\n  // to the GeoJSON features array\n  function getFeature(args) {\n    var item = args.item,\n      params = args.params,\n      propFunc = args.propFunc;\n\n    var feature = { \"type\": \"Feature\" };\n\n    feature.geometry = buildGeom(item, params);\n    feature.properties = propFunc.call(item);\n\n    return feature;\n  }\n\n  function isNested(val){\n    return (/^.+\\..+$/.test(val));\n  }\n\n  // Assembles the `geometry` property\n  // for the feature output\n  function buildGeom(item, params) {\n    var geom = {},\n        attr;\n\n    for(var gtype in params.geom) {\n      var val = params.geom[gtype];\n\n      // Geometry parameter specified as: {Point: 'coords'}\n      if(typeof val === 'string' && item.hasOwnProperty(val)) {\n        if(gtype === 'GeoJSON') {\n          geom = item[val];\n        } else {\n          geom.type = gtype;\n          geom.coordinates = item[val];\n        }\n      }\n\n      /* Handle things like:\n      Polygon: {\n        northeast: ['lat', 'lng'],\n        southwest: ['lat', 'lng']\n      }\n      */\n      else if(typeof val === 'object' && !Array.isArray(val)) {\n        /*jshint loopfunc: true */\n        var points = Object.keys(val).map(function(key){\n          var order = val[key];\n          var newItem = item[key];\n          return buildGeom(newItem, {geom:{ Point: order}});\n        });\n        geom.type = gtype;\n        /*jshint loopfunc: true */\n        geom.coordinates = [].concat(points.map(function(p){\n          return p.coordinates;\n        }));\n      }\n\n      // Geometry parameter specified as: {Point: ['lat', 'lng']}\n      else if(Array.isArray(val) && item.hasOwnProperty(val[0]) && item.hasOwnProperty(val[1])){\n        geom.type = gtype;\n        geom.coordinates = [Number(item[val[1]]), Number(item[val[0]])];\n      }\n\n      // Geometry parameter specified as: {Point: ['container.lat', 'container.lng']}\n      else if(Array.isArray(val) && isNested(val[0]) && isNested(val[1])){\n        var coordinates = [];\n        for (var i = 0; i < val.length; i++) {\t// i.e. 0 and 1\n          var paths = val[i].split('.');\n          var itemClone = item;\n          for (var j = 0; j < paths.length; j++) {\n            if (!itemClone.hasOwnProperty(paths[j])) {\n              return false;\n            }\n            itemClone = itemClone[paths[j]];\t// Iterate deeper into the object\n          }\n          coordinates[i] = itemClone;\n        }\n        geom.type = gtype;\n        geom.coordinates = [Number(coordinates[1]), Number(coordinates[0])];\n      }\n    }\n\n    if(params.doThrows && params.doThrows.invalidGeometry && !GeoJSON.isGeometryValid(geom)){\n      throw new InvalidGeometryError(item, params);\n    }\n\n    return geom;\n  }\n\n  // Returns the function to be used to\n  // build the properties object for each feature\n  function getPropFunction(params) {\n    var func;\n\n    if(!params.exclude && !params.include) {\n      func = function(properties) {\n        for(var attr in this) {\n          if(this.hasOwnProperty(attr) && (geomAttrs.indexOf(attr) === -1)) {\n            properties[attr] = this[attr];\n          }\n        }\n      };\n    } else if(params.include) {\n      func = function(properties) {\n        params.include.forEach(function(attr){\n          properties[attr] = this[attr];\n        }, this);\n      };\n    } else if(params.exclude) {\n      func = function(properties) {\n        for(var attr in this) {\n          if(this.hasOwnProperty(attr) && (geomAttrs.indexOf(attr) === -1) && (params.exclude.indexOf(attr) === -1)) {\n            properties[attr] = this[attr];\n          }\n        }\n      };\n    }\n\n    return function() {\n      var properties = {};\n\n      func.call(this, properties);\n\n      if(params.extra) { addExtra(properties, params.extra); }\n      return properties;\n    };\n  }\n\n  // Adds data contained in the `extra`\n  // parameter if it has been specified\n  function addExtra(properties, extra) {\n    for(var key in extra){\n      if(extra.hasOwnProperty(key)) {\n        properties[key] = extra[key];\n      }\n    }\n\n    return properties;\n  }\n\n}(typeof module == 'object' ? module.exports : window.GeoJSON = {}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}